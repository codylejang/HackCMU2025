{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///Users/atlantix/Desktop/ent/LLMBookReader/HackCMU2025/frontend/src/app/api/books/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getAllBooks, addBook, deleteBook } from '@/lib/database';\nimport { saveUploadedFile, generateBookCover, extractTextContent } from '@/lib/fileUpload';\nimport path from 'path';\n\nexport async function GET() {\n  try {\n    const books = getAllBooks();\n    return NextResponse.json({\n      success: true,\n      data: books\n    });\n  } catch (error) {\n    console.error('Error fetching books:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to fetch books' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n    const author = formData.get('author') as string;\n    \n    if (!file) {\n      return NextResponse.json(\n        { success: false, error: 'No file provided' },\n        { status: 400 }\n      );\n    }\n\n    // Validate file type\n    const allowedTypes = ['application/pdf', 'application/epub+zip', 'text/plain'];\n    if (!allowedTypes.includes(file.type)) {\n      return NextResponse.json(\n        { success: false, error: 'Invalid file type. Only PDF, EPUB, and TXT files are allowed.' },\n        { status: 400 }\n      );\n    }\n\n    // Validate file size (10MB limit)\n    const maxSize = 10 * 1024 * 1024; // 10MB\n    if (file.size > maxSize) {\n      return NextResponse.json(\n        { success: false, error: 'File size too large. Maximum size is 10MB.' },\n        { status: 400 }\n      );\n    }\n\n    // Save the uploaded file\n    const uploadResult = await saveUploadedFile(file);\n    if (!uploadResult.success) {\n      return NextResponse.json(\n        { success: false, error: uploadResult.error || 'Failed to save file' },\n        { status: 500 }\n      );\n    }\n\n    // Determine file type\n    const fileType = file.type === 'application/pdf' ? 'pdf' : \n                    file.type === 'application/epub+zip' ? 'epub' : 'txt';\n\n    // Extract text content with error handling\n    let content: string;\n    try {\n      content = await extractTextContent(uploadResult.filePath!, fileType);\n    } catch (error) {\n      console.error('Content extraction failed:', error);\n      content = `# ${file.name}\\n\\n**Error:** Content extraction failed.\\n\\n**Details:** ${error instanceof Error ? error.message : 'Unknown error'}\\n\\n**File Type:** ${fileType.toUpperCase()}\\n\\n**Note:** The file was uploaded but content could not be extracted.`;\n    }\n\n    // Extract proper title from file metadata\n    let title = file.name.replace(/\\.[^/.]+$/, \"\"); // Default to filename\n    let bookAuthor = 'Unknown';\n    \n    // For EPUB files, try to extract actual title and author from metadata\n    if (fileType === 'epub') {\n      try {\n        const epub = require('epub');\n        const epubInstance = new epub(uploadResult.filePath!);\n        \n        await new Promise((resolve, reject) => {\n          epubInstance.on('end', () => {\n            if (epubInstance.metadata) {\n              if (epubInstance.metadata.title) {\n                title = epubInstance.metadata.title;\n              }\n              if (epubInstance.metadata.creator) {\n                bookAuthor = epubInstance.metadata.creator;\n              }\n            }\n            resolve(true);\n          });\n          \n          epubInstance.on('error', (err: any) => {\n            console.log('EPUB metadata extraction failed, using filename:', err);\n            resolve(true); // Continue with filename as fallback\n          });\n          \n          epubInstance.parse();\n        });\n      } catch (error) {\n        console.log('EPUB metadata extraction failed, using filename:', error);\n      }\n    }\n    \n    // Generate book cover with error handling\n    let finalCoverPath = uploadResult.coverPath!;\n    try {\n      const coverGenerated = await generateBookCover(title, fileType, uploadResult.coverPath!, uploadResult.filePath);\n      if (coverGenerated) {\n        // Check if the cover path was changed (e.g., from PNG to SVG for failed extraction)\n        const expectedExtension = (fileType === 'pdf' || fileType === 'epub') ? '.png' : '.svg';\n        const actualExtension = path.extname(uploadResult.coverPath!);\n        if (actualExtension !== expectedExtension) {\n          // Update the cover path to match the actual file created\n          finalCoverPath = uploadResult.coverPath!.replace(actualExtension, expectedExtension);\n        }\n      }\n    } catch (error) {\n      console.error('Cover generation failed:', error);\n      // Continue without cover - the system will handle missing covers gracefully\n    }\n\n    // Create book record\n    const newBook = {\n      id: uploadResult.bookId!,\n      title,\n      author: bookAuthor,\n      fileType: fileType as 'pdf' | 'epub' | 'txt',\n      uploadDate: new Date().toISOString(),\n      filePath: uploadResult.filePath!,\n      coverPath: finalCoverPath || '', // Use the final cover path\n      fileSize: file.size,\n      content,\n      currentPage: 1 // Initialize to page 1\n    };\n\n    // Save to database\n    const savedBook = addBook(newBook);\n\n    return NextResponse.json({\n      success: true,\n      data: savedBook\n    });\n  } catch (error) {\n    console.error('Error uploading book:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to upload book' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const bookId = searchParams.get('id');\n    \n    if (!bookId) {\n      return NextResponse.json(\n        { success: false, error: 'Book ID is required' },\n        { status: 400 }\n      );\n    }\n\n    const success = deleteBook(bookId);\n    if (!success) {\n      return NextResponse.json(\n        { success: false, error: 'Book not found' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: 'Book deleted successfully'\n    });\n  } catch (error) {\n    console.error('Error deleting book:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to delete book' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}