{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyunwooyi/Documents/Projects/HackCMU2025/src/lib/database.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nexport interface Book {\n  id: string;\n  title: string;\n  author?: string;\n  fileType: 'pdf' | 'epub' | 'txt';\n  uploadDate: string;\n  filePath: string;\n  coverPath?: string;\n  fileSize: number;\n  content?: string;\n  currentPage?: number;\n}\n\nconst DATABASE_PATH = path.join(process.cwd(), 'data', 'database', 'books.json');\n\n// Ensure database file exists\nfunction ensureDatabaseExists() {\n  const dbDir = path.dirname(DATABASE_PATH);\n  if (!fs.existsSync(dbDir)) {\n    fs.mkdirSync(dbDir, { recursive: true });\n  }\n  \n  if (!fs.existsSync(DATABASE_PATH)) {\n    fs.writeFileSync(DATABASE_PATH, JSON.stringify([], null, 2));\n  }\n}\n\n// Read all books from database\nexport function getAllBooks(): Book[] {\n  ensureDatabaseExists();\n  try {\n    const data = fs.readFileSync(DATABASE_PATH, 'utf8');\n    return JSON.parse(data);\n  } catch (error) {\n    console.error('Error reading books database:', error);\n    return [];\n  }\n}\n\n// Get a single book by ID\nexport function getBookById(id: string): Book | null {\n  const books = getAllBooks();\n  return books.find(book => book.id === id) || null;\n}\n\n// Add a new book to database\nexport function addBook(book: Book): Book {\n  ensureDatabaseExists();\n  const books = getAllBooks();\n  books.push(book);\n  fs.writeFileSync(DATABASE_PATH, JSON.stringify(books, null, 2));\n  return book;\n}\n\n// Update an existing book\nexport function updateBook(id: string, updates: Partial<Book>): Book | null {\n  ensureDatabaseExists();\n  const books = getAllBooks();\n  const index = books.findIndex(book => book.id === id);\n  \n  if (index === -1) {\n    return null;\n  }\n  \n  books[index] = { ...books[index], ...updates };\n  fs.writeFileSync(DATABASE_PATH, JSON.stringify(books, null, 2));\n  return books[index];\n}\n\n// Delete a book from database\nexport function deleteBook(id: string): boolean {\n  ensureDatabaseExists();\n  const books = getAllBooks();\n  const index = books.findIndex(book => book.id === id);\n  \n  if (index === -1) {\n    return false;\n  }\n  \n  const book = books[index];\n  \n  // Remove the book from array\n  books.splice(index, 1);\n  fs.writeFileSync(DATABASE_PATH, JSON.stringify(books, null, 2));\n  \n  // Delete associated files\n  try {\n    if (fs.existsSync(book.filePath)) {\n      fs.unlinkSync(book.filePath);\n    }\n    if (book.coverPath && fs.existsSync(book.coverPath)) {\n      fs.unlinkSync(book.coverPath);\n    }\n  } catch (error) {\n    console.error('Error deleting book files:', error);\n  }\n  \n  return true;\n}\n\n// Generate unique filename\nexport function generateUniqueFilename(originalName: string): string {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const ext = path.extname(originalName);\n  const name = path.basename(originalName, ext);\n  return `${name}_${timestamp}_${random}${ext}`;\n}\n\n// Generate book ID\nexport function generateBookId(): string {\n  return `book_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;;;AAeA,MAAM,gBAAgB,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ,YAAY;AAEnE,8BAA8B;AAC9B,SAAS;IACP,MAAM,QAAQ,4GAAI,CAAC,OAAO,CAAC;IAC3B,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,QAAQ;QACzB,wGAAE,CAAC,SAAS,CAAC,OAAO;YAAE,WAAW;QAAK;IACxC;IAEA,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,gBAAgB;QACjC,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,EAAE,EAAE,MAAM;IAC3D;AACF;AAGO,SAAS;IACd;IACA,IAAI;QACF,MAAM,OAAO,wGAAE,CAAC,YAAY,CAAC,eAAe;QAC5C,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,EAAE;IACX;AACF;AAGO,SAAS,YAAY,EAAU;IACpC,MAAM,QAAQ;IACd,OAAO,MAAM,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK,OAAO;AAC/C;AAGO,SAAS,QAAQ,IAAU;IAChC;IACA,MAAM,QAAQ;IACd,MAAM,IAAI,CAAC;IACX,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,OAAO,MAAM;IAC5D,OAAO;AACT;AAGO,SAAS,WAAW,EAAU,EAAE,OAAsB;IAC3D;IACA,MAAM,QAAQ;IACd,MAAM,QAAQ,MAAM,SAAS,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IAElD,IAAI,UAAU,CAAC,GAAG;QAChB,OAAO;IACT;IAEA,KAAK,CAAC,MAAM,GAAG;QAAE,GAAG,KAAK,CAAC,MAAM;QAAE,GAAG,OAAO;IAAC;IAC7C,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,OAAO,MAAM;IAC5D,OAAO,KAAK,CAAC,MAAM;AACrB;AAGO,SAAS,WAAW,EAAU;IACnC;IACA,MAAM,QAAQ;IACd,MAAM,QAAQ,MAAM,SAAS,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IAElD,IAAI,UAAU,CAAC,GAAG;QAChB,OAAO;IACT;IAEA,MAAM,OAAO,KAAK,CAAC,MAAM;IAEzB,6BAA6B;IAC7B,MAAM,MAAM,CAAC,OAAO;IACpB,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,OAAO,MAAM;IAE5D,0BAA0B;IAC1B,IAAI;QACF,IAAI,wGAAE,CAAC,UAAU,CAAC,KAAK,QAAQ,GAAG;YAChC,wGAAE,CAAC,UAAU,CAAC,KAAK,QAAQ;QAC7B;QACA,IAAI,KAAK,SAAS,IAAI,wGAAE,CAAC,UAAU,CAAC,KAAK,SAAS,GAAG;YACnD,wGAAE,CAAC,UAAU,CAAC,KAAK,SAAS;QAC9B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;IAC9C;IAEA,OAAO;AACT;AAGO,SAAS,uBAAuB,YAAoB;IACzD,MAAM,YAAY,KAAK,GAAG;IAC1B,MAAM,SAAS,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;IACvD,MAAM,MAAM,4GAAI,CAAC,OAAO,CAAC;IACzB,MAAM,OAAO,4GAAI,CAAC,QAAQ,CAAC,cAAc;IACzC,OAAO,GAAG,KAAK,CAAC,EAAE,UAAU,CAAC,EAAE,SAAS,KAAK;AAC/C;AAGO,SAAS;IACd,OAAO,CAAC,KAAK,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;AAC3E","debugId":null}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyunwooyi/Documents/Projects/HackCMU2025/src/app/api/books/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getBookById } from '@/lib/database';\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id } = await params;\n    const book = getBookById(id);\n    \n    if (!book) {\n      return NextResponse.json(\n        { success: false, error: 'Book not found' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json({\n      success: true,\n      data: book\n    });\n  } catch (error) {\n    console.error('Error fetching book:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to fetch book' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QACrB,MAAM,OAAO,IAAA,uIAAW,EAAC;QAEzB,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAiB,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAAuB,GAChD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}