{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyunwooyi/Documents/Projects/HackCMU2025/src/lib/database.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nexport interface Book {\n  id: string;\n  title: string;\n  author?: string;\n  fileType: 'pdf' | 'epub' | 'txt';\n  uploadDate: string;\n  filePath: string;\n  coverPath?: string;\n  fileSize: number;\n  content?: string;\n  currentPage?: number;\n}\n\nconst DATABASE_PATH = path.join(process.cwd(), 'data', 'database', 'books.json');\n\n// Ensure database file exists\nfunction ensureDatabaseExists() {\n  const dbDir = path.dirname(DATABASE_PATH);\n  if (!fs.existsSync(dbDir)) {\n    fs.mkdirSync(dbDir, { recursive: true });\n  }\n  \n  if (!fs.existsSync(DATABASE_PATH)) {\n    fs.writeFileSync(DATABASE_PATH, JSON.stringify([], null, 2));\n  }\n}\n\n// Read all books from database\nexport function getAllBooks(): Book[] {\n  ensureDatabaseExists();\n  try {\n    const data = fs.readFileSync(DATABASE_PATH, 'utf8');\n    return JSON.parse(data);\n  } catch (error) {\n    console.error('Error reading books database:', error);\n    return [];\n  }\n}\n\n// Get a single book by ID\nexport function getBookById(id: string): Book | null {\n  const books = getAllBooks();\n  return books.find(book => book.id === id) || null;\n}\n\n// Add a new book to database\nexport function addBook(book: Book): Book {\n  ensureDatabaseExists();\n  const books = getAllBooks();\n  books.push(book);\n  fs.writeFileSync(DATABASE_PATH, JSON.stringify(books, null, 2));\n  return book;\n}\n\n// Update an existing book\nexport function updateBook(id: string, updates: Partial<Book>): Book | null {\n  ensureDatabaseExists();\n  const books = getAllBooks();\n  const index = books.findIndex(book => book.id === id);\n  \n  if (index === -1) {\n    return null;\n  }\n  \n  books[index] = { ...books[index], ...updates };\n  fs.writeFileSync(DATABASE_PATH, JSON.stringify(books, null, 2));\n  return books[index];\n}\n\n// Delete a book from database\nexport function deleteBook(id: string): boolean {\n  ensureDatabaseExists();\n  const books = getAllBooks();\n  const index = books.findIndex(book => book.id === id);\n  \n  if (index === -1) {\n    return false;\n  }\n  \n  const book = books[index];\n  \n  // Remove the book from array\n  books.splice(index, 1);\n  fs.writeFileSync(DATABASE_PATH, JSON.stringify(books, null, 2));\n  \n  // Delete associated files\n  try {\n    if (fs.existsSync(book.filePath)) {\n      fs.unlinkSync(book.filePath);\n    }\n    if (book.coverPath && fs.existsSync(book.coverPath)) {\n      fs.unlinkSync(book.coverPath);\n    }\n  } catch (error) {\n    console.error('Error deleting book files:', error);\n  }\n  \n  return true;\n}\n\n// Generate unique filename\nexport function generateUniqueFilename(originalName: string): string {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const ext = path.extname(originalName);\n  const name = path.basename(originalName, ext);\n  return `${name}_${timestamp}_${random}${ext}`;\n}\n\n// Generate book ID\nexport function generateBookId(): string {\n  return `book_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;;;AAeA,MAAM,gBAAgB,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ,YAAY;AAEnE,8BAA8B;AAC9B,SAAS;IACP,MAAM,QAAQ,4GAAI,CAAC,OAAO,CAAC;IAC3B,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,QAAQ;QACzB,wGAAE,CAAC,SAAS,CAAC,OAAO;YAAE,WAAW;QAAK;IACxC;IAEA,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,gBAAgB;QACjC,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,EAAE,EAAE,MAAM;IAC3D;AACF;AAGO,SAAS;IACd;IACA,IAAI;QACF,MAAM,OAAO,wGAAE,CAAC,YAAY,CAAC,eAAe;QAC5C,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,EAAE;IACX;AACF;AAGO,SAAS,YAAY,EAAU;IACpC,MAAM,QAAQ;IACd,OAAO,MAAM,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK,OAAO;AAC/C;AAGO,SAAS,QAAQ,IAAU;IAChC;IACA,MAAM,QAAQ;IACd,MAAM,IAAI,CAAC;IACX,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,OAAO,MAAM;IAC5D,OAAO;AACT;AAGO,SAAS,WAAW,EAAU,EAAE,OAAsB;IAC3D;IACA,MAAM,QAAQ;IACd,MAAM,QAAQ,MAAM,SAAS,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IAElD,IAAI,UAAU,CAAC,GAAG;QAChB,OAAO;IACT;IAEA,KAAK,CAAC,MAAM,GAAG;QAAE,GAAG,KAAK,CAAC,MAAM;QAAE,GAAG,OAAO;IAAC;IAC7C,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,OAAO,MAAM;IAC5D,OAAO,KAAK,CAAC,MAAM;AACrB;AAGO,SAAS,WAAW,EAAU;IACnC;IACA,MAAM,QAAQ;IACd,MAAM,QAAQ,MAAM,SAAS,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;IAElD,IAAI,UAAU,CAAC,GAAG;QAChB,OAAO;IACT;IAEA,MAAM,OAAO,KAAK,CAAC,MAAM;IAEzB,6BAA6B;IAC7B,MAAM,MAAM,CAAC,OAAO;IACpB,wGAAE,CAAC,aAAa,CAAC,eAAe,KAAK,SAAS,CAAC,OAAO,MAAM;IAE5D,0BAA0B;IAC1B,IAAI;QACF,IAAI,wGAAE,CAAC,UAAU,CAAC,KAAK,QAAQ,GAAG;YAChC,wGAAE,CAAC,UAAU,CAAC,KAAK,QAAQ;QAC7B;QACA,IAAI,KAAK,SAAS,IAAI,wGAAE,CAAC,UAAU,CAAC,KAAK,SAAS,GAAG;YACnD,wGAAE,CAAC,UAAU,CAAC,KAAK,SAAS;QAC9B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;IAC9C;IAEA,OAAO;AACT;AAGO,SAAS,uBAAuB,YAAoB;IACzD,MAAM,YAAY,KAAK,GAAG;IAC1B,MAAM,SAAS,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;IACvD,MAAM,MAAM,4GAAI,CAAC,OAAO,CAAC;IACzB,MAAM,OAAO,4GAAI,CAAC,QAAQ,CAAC,cAAc;IACzC,OAAO,GAAG,KAAK,CAAC,EAAE,UAAU,CAAC,EAAE,SAAS,KAAK;AAC/C;AAGO,SAAS;IACd,OAAO,CAAC,KAAK,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;AAC3E","debugId":null}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyunwooyi/Documents/Projects/HackCMU2025/src/app/api/books/%5Bid%5D/current-page/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { updateBook } from '@/lib/database';\n\nexport async function PUT(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const { id } = params;\n    const { currentPage } = await request.json();\n\n    console.log('API: Updating current page:', { id, currentPage });\n\n    if (typeof currentPage !== 'number' || currentPage < 1) {\n      console.log('API: Invalid current page number');\n      return NextResponse.json(\n        { success: false, error: 'Invalid current page number' },\n        { status: 400 }\n      );\n    }\n\n    const updatedBook = updateBook(id, { currentPage });\n    console.log('API: Updated book:', { id, currentPage: updatedBook?.currentPage });\n\n    if (!updatedBook) {\n      console.log('API: Book not found');\n      return NextResponse.json(\n        { success: false, error: 'Book not found' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json({\n      success: true,\n      data: { currentPage: updatedBook.currentPage }\n    });\n  } catch (error) {\n    console.error('Error updating current page:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to update current page' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  // Handle sendBeacon requests (which use POST)\n  return PUT(request, { params });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,eAAe,IACpB,OAAgB,EAChB,EAAE,MAAM,EAA8B;IAEtC,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,GAAG;QACf,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE1C,QAAQ,GAAG,CAAC,+BAA+B;YAAE;YAAI;QAAY;QAE7D,IAAI,OAAO,gBAAgB,YAAY,cAAc,GAAG;YACtD,QAAQ,GAAG,CAAC;YACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAA8B,GACvD;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,cAAc,IAAA,sIAAU,EAAC,IAAI;YAAE;QAAY;QACjD,QAAQ,GAAG,CAAC,sBAAsB;YAAE;YAAI,aAAa,aAAa;QAAY;QAE9E,IAAI,CAAC,aAAa;YAChB,QAAQ,GAAG,CAAC;YACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAiB,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;gBAAE,aAAa,YAAY,WAAW;YAAC;QAC/C;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAAgC,GACzD;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KACpB,OAAgB,EAChB,EAAE,MAAM,EAA8B;IAEtC,8CAA8C;IAC9C,OAAO,IAAI,SAAS;QAAE;IAAO;AAC/B","debugId":null}}]
}